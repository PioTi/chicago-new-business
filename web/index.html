<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">

<style>
    svg{
        /*border: 5px solid red;*/
        /*height: 100%;*/
        width: 100%;
    }
    #area1 {
      width: 40%;
      float: left;
    }
    #area2 {
      width: 60%;
      float: right;
    }

    .x.axis path {
	   display: none;
	}

    div.bar {
        display: inline-block;
        width: 20px;
        height: 75px;	/* Gets overriden by D3-assigned height below */
        margin-right: 2px;
        background-color: teal;
    }
    path{ fill: #ccc; }

    text{
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    .line {
      fill: none;
      stroke: black;
      stroke-width: 1.5px;
    }

    .active {
        stroke: black;
        stroke-width: 4px;
    }

    .neighborhood-boundary{
        fill: none;
        stroke: #120f0f;
        stroke-dasharray: 2,2;
        stroke-linejoin: round;
    }

    #legend {
        padding: 1.5em 0 0 1.5em;
    }

    ul {
        display: -webkit-box;
    }

    li.key {
        border-top-width: 10px;
        border-top-style: solid;
        font-size: .75em;
        width: 17%;
        padding-left: 0;
        padding-right: 0;
    }

    #years{
        border:0;
        font-size: 20px;
        color:#f6931f;
        font-weight:bold;
    }
</style>
<body>
    <div id="container" style="dispay:inline">
        <div id="area1">
            <p>
              <label for="Years">Years:</label>
              <input type="text" id="years" readonly>
            </p>
            <div id="dateSlider">
            </div>
        </div>
        <div id="area2">
            <div id="legend">
                <ul>
                </ul>
            </div>
        </div>
    </div>
</body>
<script src="//d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="//d3js.org/d3-queue.v1.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script src="//code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
<script>

var margin = {top: 10, left: 10, bottom: 10, right: 10}
  , width = parseInt(d3.select('#area2').style('width'))
  , width = width - margin.left - margin.right
  , mapRatio = 1
  , height = width * mapRatio;

// longitude and latitude of Chicago-ish [-87.915044,41.8333925]
var projection = d3.geo.mercator()
    // .scale( 80000 ) // trial and error
    .scale( width * 100 ) // trial and error
    .rotate( [87.915044,0] )
    .center( [0, 41.8333925] )
    .translate( [width*.2,height/2] );

var path = d3.geo.path()
    .projection(projection);

// scale for line chart
var parseDate = d3.time.format("%Y").parse;

// colorScale for map and bar chart
var colorScale = d3.scale.linear()
    .domain([-700,
             -500,
             0,
             500,
             700]) // adjust based on range in data...
    .range(['#FF0000',
            '#fc7a7a',
            '#ddd',
            '#8585fc',
            '#0000FF']);


// Persistent array of selected neighborhoods across redraws
// var activeList = ['AUSTIN', 'HUMBOLDT_PARK'];
// DEFUALT: all of Chicago
var activeList = [];

function drawChart(svg, dataset) {

    //Width and height
    var w = (parseInt(d3.select('#container').select("svg").style('width')) - 80)*.9;
    var h = height;

    var barPadding = 4;

    var x = d3.time.scale()
        .range([0, w]);

    var y = d3.scale.linear()
        .range([h*.75, h*.25]);

    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .ticks(5);

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");

    var line = d3.svg.line()
        .x(function(d) {
            return x(parseDate(d.key)); })
        .y(function(d) {
            return y(d.values.total_new - d.values.total_old);
        });

    //Create SVG element
    var svg = svg;

    // Aggregate by YEAR
    var aggByYear = d3.nest()
        .key(function(d) { return +d.year; })
        .rollup(function(leaves) {
            return {"neighborhoods": +leaves.length
                , "total_new": d3.sum(leaves, function(d) {return +d.new;})
                , "total_old": d3.sum(leaves, function(d) {return +d.old;})
        }})
        .entries(dataset);

    // Scale values based on data subset
    x.domain(d3.extent(aggByYear, function(d) { return parseDate(d.key); }));

    // Determine height of bars based on filtered data
    var maxNew = d3.max(aggByYear, function(d) { return d.values.total_new });
    var maxOld = d3.max(aggByYear, function(d) { return d.values.total_old });
    // Use value that is greater as the max & min values to fix axis position
    var maxVal = maxOld > maxNew ? maxOld : maxNew;
    y.domain([-maxVal, maxVal])

    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + h*.75 + ")")
        .call(xAxis);

    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);

    var newArray = aggByYear.map(function(a) {return a.values.total_new;});
    var oldArray = aggByYear.map(function(a) {return a.values.total_old;});

    var barWidth = w / newArray.length;

    // Rect above the axis : New Biz
    svg.selectAll(".newrect")
        .data(newArray)
        .enter()
        .append("rect")
        .attr("x", function(d, i) {
            return i * barWidth;
        })
        .attr("y", function(d) {
            return y(d);
        })
        .attr("width", barWidth - barPadding)
        .attr("height", function(d) {
           return h/2 - y(d);
        })
        .attr("class", "newrect")
        .attr("fill", function(d) {
            return colorScale(d);
        });

    // Rect below the axis : Old Biz
    svg.selectAll(".oldrect")
       .data(oldArray)
       .enter()
       .append("rect")
       .attr("x", function(d, i) {
            return i * barWidth;
        })
       .attr("y", function(d) {
            return h/2;  //Height
        })
       .attr("width", barWidth - barPadding)
       .attr("height", function(d) {
            return h/2 - y(d);
        })
        .attr("class", "oldrect")
        .attr("fill", function(d) {
            return colorScale(-d);
        });

    // Add labels to bar chart
    svg.selectAll("newtext")
        .data(newArray)
        .enter()
        .append("text")
        .text(function(d) {
            return d;
        })
        .attr("x", function(d, i) {
            return i * barWidth
                + (barWidth - barPadding) / 2;
        })
        .attr("y", function(d) {
            return  y(d) + 14;
        })
        .attr("class", "newtext")
        .style("font-size", "12px")
        .style("fill", "white")
        .attr("text-anchor", "middle");

    // labels on for Old Biz
    svg.selectAll("oldtext")
        .data(oldArray)
        .enter()
        .append("text")
        .text(function(d) {
           return d;
        })
        .attr("x", function(d, i) {
           return i * barWidth
               + (barWidth - barPadding) / 2;
        })
        .attr("y", function(d) {
           return h - y(d) -8;
        })
        .attr("class", "oldtext")
        .style("font-size", "12px")
        .style("fill", "white")
        .attr("text-anchor", "middle");

    //  Line on barchart
    svg.append("path")
        .datum(aggByYear)
        .attr("class", "line")
        .attr("d", line);
}
chart = d3.select("#area1").select("svg");

function redraw() {
    // Asynchronously Load Data Before Drawing Map
    queue()
      .defer(d3.json, "merged_neighborhoods.topojson")
      .defer(d3.csv, "neighborhood_businesses_per_year.csv")
      .await(drawMap);

    function drawMap(error, json, csv) {
        if (error) return console.error(error);

        var minDate = $( "#dateSlider" ).slider( "values", 0 );
        var maxDate = $( "#dateSlider" ).slider( "values", 1 );

        // Remove SVG if it exists
        if ($("svg").length > 0) {
            // lookup = {};
            $("svg").remove()
        }

        // var chartW = parseInt(d3.select('#container').style('width'))*.2
        var chartSvg = d3.select("#area1").append("svg")
            .attr("width", width )
            .attr("height", height)
          .append("g")
            .attr("transform", "translate(" + 80 + ", 0)");

        var map = d3.select("#area2").append("svg")
            .attr("width", width)
            .attr("height", height);

        var g = map.append( "g" );

        // Filter by Date Range selected
        function isInDateRange(value) {
            if (minDate == maxDate) {
                return value == minDate;
            }
            else {
                return value >= minDate && value <= maxDate;
            }
        }

        // Filter if in list
        function isInArray(value, array) {
            return array.indexOf(value) > -1;
        }

        // filter by date for coloring all neighborhoods on map
        filteredStats = csv.filter(function(d) {return isInDateRange(d.year);});
        // FOR LINE BAR CHART: filter by class for selected neighborhoods
        activeStats = filteredStats.filter(function (d) {
            var name = d.neighborhood.replace("&", "AND")
                        .split(",").join(" ").replace(/ /g, "_")
            return isInArray(name, activeList);
        });
        // if no neighborhoods selected, then barchart is for all of Chicago
        activeStats = activeStats.length > 0 ? activeStats : filteredStats;
        drawChart(chartSvg, activeStats);

        // Aggregate by Neighborhood
        var result = d3.nest()
            .key(function(d) { return d.neighborhood; })
            .rollup(function(leaves) {
                return {"years": +leaves.length
                    , "total_new": d3.sum(leaves, function(d) {return +d.new;})
                    , "total_old": d3.sum(leaves, function(d) {return +d.old;})
            }})
            .entries(filteredStats);

        // Create Lookup for Neighborhood Stats
        var lookup = {};
        for (var i = 0, len = result.length; i < len; i++) {
            lookup[result[i].key] = result[i];
        }

        var neighborhoods = topojson.feature(json,
            json.objects.merged_neighborhoods).features;

        // Add stats to neighborhoods
        neighborhoods.forEach( function(d) {
            var stats = lookup[d.id].values;
            d.id = d.id.replace("&", "AND").split(",").join(" ").replace(/ /g, "_");
            d.total_old = stats.total_old ? stats.total_old: 0;
            d.total_new = stats.total_new ? stats.total_new: 0;
            d.change = d.total_new - d.total_old;
        })

        function inactiveHoverStyle(d,mode) {
            var mode = mode ? mode : "over";
            if (mode == "over") {
                d3.selectAll(".neighborhood" + d.id)
                    .style("fill", "yellow");
                d3.selectAll(".neighborhood" + d.id)
                    .style("opacity", ".3");
            }
            else {
                d3.selectAll(".neighborhood" + d.id)
                    .style("fill", colorScale(d.change));
                d3.selectAll(".neighborhood" + d.id)
                    .style("opacity", "1");
            }
        }

        function addActiveClass(d){
            d3.selectAll(".neighborhood" + d.id).classed("active", true);
            activeList.push(d.id);
        }

        function removeActiveClass(d){
            d3.selectAll(".neighborhood" + d.id).classed("active", false);
            // Find and remove item from an array
            var i = activeList.indexOf(d.id);
            if(i != -1) { activeList.splice(i, 1); }
        }

        g.selectAll( "path" )
            .data( neighborhoods )
          .enter()
            .append( "path" )
            .attr("class", function(d) {
                return isInArray(d.id, activeList) ?
                    "neighborhood" + d.id + " active" + " neighborhood":
                    "neighborhood" + d.id  + " neighborhood"; })
            .attr("d", path)
            .style("fill", function(d) { return colorScale(d.change); })
            .on("mouseover", function(d) {
                // if not active, activate hover logic
                !d3.selectAll(".neighborhood" + d.id).classed("active") ?
                    inactiveHoverStyle(d,"over"):null;
                // show labels on mouseover
                d3.select(".neighborhood-label-backer" + d.id)
                    .style("display","block");
                d3.select(".neighborhood-label" + d.id)
                    .style("display","block");
            })
            .on("mouseout", function(d) {
                // if not active, activate hover logic
                !d3.selectAll(".neighborhood" + d.id).classed("active") ?
                    inactiveHoverStyle(d,"out"):null;
                // show labels on mouseout
                d3.select(".neighborhood-label-backer" + d.id)
                    .style("display","none");
                d3.select(".neighborhood-label" + d.id)
                    .style("display", "none");
            })
            .on("click", function(d) {
                // Add | Remove active class on click
                d3.selectAll(".neighborhood" + d.id).classed("active") ?
                    removeActiveClass(d):
                    addActiveClass(d);
                redraw();
            });

        // Neighborhood Boundaries ONLY between Neighborhoods
        g.append("path")
            .datum(topojson.mesh(json,json.objects.neighborhoods,
                function(a, b) { return a.id !== b.id; }))
            .attr("d", path)
            .attr("class", "neighborhood-boundary");

        // neighborhood-labels: hidden by default
        g.selectAll(".neighborhood-label-backer")
            .data( neighborhoods )
          .enter().append("text")
            .attr("class", function(d) {
                return "neighborhood-label-backer" + d.id
                + " neighborhood-label-backer"; })
            .attr("transform", function(d) {
                return "translate(" + path.centroid(d) + ")"; })
            .text(function(d) { return d.id.replace(/_/g, " "); })
            .style("display", "none")
            .style("stroke-width", "3px")
            .style("stroke", "white");

        g.selectAll(".neighborhood-label")
            .data( neighborhoods )
          .enter().append("text")
            .attr("class", function(d) {
                return "neighborhood-label" + d.id
                + " neighborhood-label"; })
            .attr("transform", function(d) {
                return "translate(" + path.centroid(d) + ")"; })
            .text(function(d) { return d.id.replace(/_/g, " "); })
            .style("display", "none");
    };

    var legend = d3.select("#legend").select("ul");
    var colors = colorScale.range().reverse();
    var keys = legend.selectAll('li.key')
        .data(colors);

    keys.enter().append('li')
        .attr('class', 'key')
        .style('border-top-color', String)
        .style('display','block')
        .text(function(d,i) {
            return -colorScale.domain()[i];
        })
        .attr('x', -10);

};

redraw();

d3.select(window).on('resize', resize);

function resizeChart() {
    // adjust things when the window size changes
    width = (parseInt(d3.select('#container').select("svg").style('width')) - 80) *.9;
    // Same height as MAP svg
    height = parseInt(d3.select('#area2').select("svg").style('height'));

    chart = d3.select("#area1").select("svg");
    // resize the chart container
    chart
        .style('height', height + 'px');

    // resize the chart
    var x = d3.time.scale()
        .range([0, width]);

    var y = d3.scale.linear()
        .range([height*.75, height*.25]);

    // Determine height of bars based on filtered data
    newArray = chart.selectAll('.newrect').data()
    oldArray = chart.selectAll('.oldrect').data()

    var maxNew = d3.max(newArray);
    var maxOld = d3.max(oldArray);
    // Use value that is greater as the max & min values to fix axis position
    var maxVal = maxOld > maxNew ? maxOld : maxNew;
    y.domain([-maxVal, maxVal])

    // var minDate = document.getElementById('minDate').value?
    //               document.getElementById('minDate').value: 2004;
    // var maxDate = document.getElementById('maxDate').value?
    //               document.getElementById('maxDate').value: 2015;

    var minDate = $( "#dateSlider" ).slider( "values", 0 );
    var maxDate = $( "#dateSlider" ).slider( "values", 1 );

    x.domain([parseDate(minDate), parseDate(maxDate)]);

    var barWidth = width / newArray.length;
    var barPadding = 4;

    chart.selectAll('.newrect')
        .attr("x", function(d, i) {
            return i * barWidth;
        })
        .attr("y", function(d) {
            return y(d);
        })
        .attr('width', barWidth - barPadding)
        .attr("height", function(d) {
            return height/2 - y(d);
       });

    chart.selectAll('.oldrect')
        .attr("x", function(d, i) {
            return i * barWidth;
        })
        .attr("y", function(d) {
            return height/2;
        })
        .attr('width', barWidth - barPadding)
        .attr("height", function(d) {
            return height/2 - y(d);
        });

    chart.selectAll('.newtext')
        .attr("x", function(d, i) {
            return i * barWidth
                + (barWidth - barPadding) / 2;
        })
        .attr("y", function(d) {
            return y(d) + 14;
        });

    chart.selectAll('.oldtext')
        .attr("x", function(d, i) {
           return i * barWidth
               + (barWidth - barPadding) / 2;
        })
        .attr("y", function(d) {
           return height - y(d) -8;
        })

    // update axes
    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");

    chart.select('.y.axis').call(yAxis);

    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .ticks(5);

    chart.select('.x.axis')
        .attr("transform", "translate(0," + height*.75 + ")")
        .call(xAxis);

    // update line
    var line = d3.svg.line()
        .x(function(d) {
            return x(parseDate(d.key)); })
        .y(function(d) {
            return y(d.values.total_new - d.values.total_old);
        });

    chart.selectAll('.line')
      .attr("d", function(d) { return line(d); });

}

function resizeMap() {
    // adjust things when the window size changes
    width = parseInt(d3.select('#area2').style('width'));
    width = width
    // - margin.left - margin.right;
    mapRatio = 1;
    height = width * mapRatio;

    // update projection
    projection
        .translate([width *.2, height / 2])
        .scale(width*100);

    map = d3.select("#area2").select("svg");
    // resize the map container
    map
        .style('width', width + 'px')
        .style('height', height + 'px');

    // resize the map
    map.selectAll('.neighborhood').attr('d', path);
    map.selectAll('.neighborhood-boundary').attr('d', path);
    map.selectAll('.neighborhood-label').attr('d', path)
        .attr("transform", function(d) {
            return "translate(" + path.centroid(d) + ")"; });
    map.selectAll('.neighborhood-label-backer').attr('d', path)
        .attr("transform", function(d) {
            return "translate(" + path.centroid(d) + ")"; });
}

function resize() {
    resizeMap();
    resizeChart();
}

$(function() {
    $( "#dateSlider" ).slider({
      range: true,
      min: 2004,
      max: 2015,
      values: [ 2007, 2015 ],
      change: function( event, ui ) {
          redraw()
      },
      slide: function( event, ui ) {
        $( "#years" ).val( ui.values[ 0 ] + " - " + ui.values[ 1 ] );
      }
    });
    $( "#years" ).val( $( "#dateSlider" ).slider( "values", 0 ) +
      " - " + $( "#dateSlider" ).slider( "values", 1 ) );
  });

</script>
