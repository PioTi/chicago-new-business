<!DOCTYPE html>
<meta charset="utf-8">
<style>
    svg{
        /*border: 5px solid red;*/
        /*height: 100%;*/
        width: 100%;
    }
    #area1 {
      width: 40%;
      float: right;
    }
    #area2 {
      width: 60%;
      float: left;
    }

    .x.axis path {
	   display: none;
	}

    div.bar {
        display: inline-block;
        width: 20px;
        height: 75px;	/* Gets overriden by D3-assigned height below */
        margin-right: 2px;
        background-color: teal;
    }
    path{ fill: #ccc; }

    text{
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    .line {
      fill: none;
      stroke: black;
      stroke-width: 1.5px;
    }

    .active {
        stroke: black;
        stroke-width: 4px;
    }

    .neighborhood-boundary{
        fill: none;
        stroke: #120f0f;
        stroke-dasharray: 2,2;
        stroke-linejoin: round;
    }

</style>
<body>
    <form id="years" onchange="redraw()">
        Min Year<input id="minDate" type="number" name="minDate" value="2007" min="2004" max="2015"></input>
        Max Year<input id="maxDate" type="number" name="maxDate" value="2015" min="2004" max="2015"></input>
    </form>
    <div id="container" style="dispay:inline">
        <div id="area2">
        </div>
        <div id="area1">
        </div>
    </div>
</body>
<script src="//d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="//d3js.org/d3-queue.v1.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<script>

var margin = {top: 40, right: 40, bottom: 40, left: 60};

var width = 280,
    height = 800;

// scale for line chart
var parseDate = d3.time.format("%Y").parse;

// colorScale for map and bar chart
var colorScale = d3.scale.linear()
    .domain([-700,
             -500,
             0,
             500,
             700]) // adjust based on range in data...
    .range(['#FF0000',
            '#fc7a7a',
            '#ddd',
            '#8585fc',
            '#0000FF']);

// Persistent array of selected neighborhoods across redraws
// var activeList = ['AUSTIN', 'HUMBOLDT_PARK'];
// DEFUALT: all of Chicago
var activeList = [];

function drawChart(svg, dataset) {

    //Width and height
    var w = 400;
    var h = 900;

    var barPadding = 4;

    var x = d3.time.scale()
        .range([0, w ]);

    var y = d3.scale.linear()
        .range([h*.75, h*.25]);

    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .ticks(5);

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");

    var line = d3.svg.line()
        .x(function(d) {
            return x(parseDate(d.key)); })
        .y(function(d) {
            return y(d.values.total_new - d.values.total_old);
        });

    //Create SVG element
    var svg = svg;

    // Aggregate by YEAR
    var aggByYear = d3.nest()
        .key(function(d) { return +d.year; })
        .rollup(function(leaves) {
            return {"neighborhoods": +leaves.length
                , "total_new": d3.sum(leaves, function(d) {return +d.new;})
                , "total_old": d3.sum(leaves, function(d) {return +d.old;})
        }})
        .entries(dataset);

    // Scale values based on data subset
    x.domain(d3.extent(aggByYear, function(d) { return parseDate(d.key); }));

    var maxNew = d3.max(aggByYear, function(d) { return d.values.total_new });
    var maxOld = d3.max(aggByYear, function(d) { return d.values.total_old });
    // Use value that is greater as the max & min values to fix axis position
    var maxVal = maxOld > maxNew ? maxOld : maxNew;
    y.domain([-maxVal, maxVal])

    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + h*.75 + ")")
        .call(xAxis);

    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);

    var newArray = aggByYear.map(function(a) {return a.values.total_new;});
    var oldArray = aggByYear.map(function(a) {return a.values.total_old;});

    // Rect above the axis : New Biz
    svg.selectAll(".newrect")
        .data(newArray)
        .enter()
        .append("rect")
        .attr("x", function(d, i) {
            console.log(i,w,w / newArray.length, i * (w / newArray.length))
            return i * (w / newArray.length);
        })
        .attr("y", function(d) {
            return y(d);
        })
        .attr("width", w / newArray.length - barPadding)
        .attr("height", function(d) {
           return h/2 - y(d);
        })
        .attr("class", "newrect")
        .attr("fill", function(d) {
            return colorScale(d);
        })
        ;

    // Rect below the axis : Old Biz
    svg.selectAll(".oldrect")
       .data(oldArray)
       .enter()
       .append("rect")
       .attr("x", function(d, i) {
            return i * (w / oldArray.length);
        })
       .attr("y", function(d) {
            return h/2;  //Height
        })
       .attr("width", w / oldArray.length - barPadding)
       .attr("height", function(d) {
            return h/2 - y(d);
        })
        .attr("class", "oldrect")
        .attr("fill", function(d) {
            return colorScale(-d);
        });

    // Add labels to bar chart
    svg.selectAll("newtext")
        .data(newArray)
        .enter()
        .append("text")
        .text(function(d) {
            return d;
        })
        .attr("x", function(d, i) {
            return i * (w / newArray.length)
                + (w / newArray.length - barPadding) / 2;
        })
        .attr("y", function(d) {
            return  y(d) + 14;
        })
        .attr("class", "newtext")
        .style("font-size", "12px")
        .style("fill", "white")
        .attr("text-anchor", "middle");

    // labels on for Old Biz
    svg.selectAll("oldtext")
        .data(oldArray)
        .enter()
        .append("text")
        .text(function(d) {
           return d;
        })
        .attr("x", function(d, i) {
           return i * (w / oldArray.length)
               + (w / oldArray.length - barPadding) / 2;
        })
        .attr("y", function(d) {
           return h - y(d) -8;
        })
        .attr("class", "oldtext")
        .style("font-size", "12px")
        .style("fill", "white")
        .attr("text-anchor", "middle");

    //  Line on barchart
    svg.append("path")
        .datum(aggByYear)
        .attr("class", "line")
        .attr("d", line);
}

function redraw() {
    // Asynchronously Load Data Before Drawing Map
    queue()
      .defer(d3.json, "merged_neighborhoods.topojson")
      .defer(d3.csv, "neighborhood_businesses_per_year.csv")
      .await(drawMap);

    function drawMap(error, json, csv) {
        if (error) return console.error(error);

        var minDate = document.getElementById('minDate').value?
                      document.getElementById('minDate').value: 2004;
        var maxDate = document.getElementById('maxDate').value?
                      document.getElementById('maxDate').value: 2015;

        // Remove SVG if it exists
        if ($("svg").length > 0) {
            // lookup = {};
            $("svg").remove()
        }

        var chartSvg = d3.select("#area1").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height)
          .append("g")
            .attr("transform", "translate(" + margin.left + ", 0)");;

        var map = d3.select("#area2").append("svg")
            .attr("width", width)
            .attr("height", height);

        var g = map.append( "g" );

        // Filter by Date Range selected
        function isInDateRange(value) {
          return value >= minDate && value <= maxDate;
        }

        // Filter if in list
        function isInArray(value, array) {
            return array.indexOf(value) > -1;
        }

        // filter by date for coloring all neighborhoods on map
        filteredStats = csv.filter(function(d) {return isInDateRange(d.year);});
        // FOR LINE BAR CHART: filter by class for selected neighborhoods
        activeStats = filteredStats.filter(function (d) {
            var name = d.neighborhood.replace("&", "AND")
                        .split(",").join(" ").replace(/ /g, "_")
            return isInArray(name, activeList);
        });
        // if no neighborhoods selected, then barchart is for all of Chicago
        activeStats = activeStats.length > 0 ? activeStats : filteredStats;
        drawChart(chartSvg, activeStats);

        // Aggregate by Neighborhood
        var result = d3.nest()
            .key(function(d) { return d.neighborhood; })
            .rollup(function(leaves) {
                return {"years": +leaves.length
                    , "total_new": d3.sum(leaves, function(d) {return +d.new;})
                    , "total_old": d3.sum(leaves, function(d) {return +d.old;})
            }})
            .entries(filteredStats);

        // Create Lookup for Neighborhood Stats
        var lookup = {};
        for (var i = 0, len = result.length; i < len; i++) {
            lookup[result[i].key] = result[i];
        }

        var neighborhoods = topojson.feature(json,
            json.objects.merged_neighborhoods).features;

        // Add stats to neighborhoods
        neighborhoods.forEach( function(d) {
            var stats = lookup[d.id].values;
            d.id = d.id.replace("&", "AND").split(",").join(" ").replace(/ /g, "_");
            d.total_old = stats.total_old ? stats.total_old: 0;
            d.total_new = stats.total_new ? stats.total_new: 0;
            d.change = d.total_new - d.total_old;
        })

        // longitude and latitude of Chicago-ish [-87.915044,41.8333925]
        var projection = d3.geo.mercator()
            .scale( 80000 ) // trial and error
            .rotate( [87.915044,0] )
            .center( [0, 41.8333925] )
            .translate( [width/2,height/2] );

        var path = d3.geo.path()
            .projection(projection);

        function inactiveHoverStyle(d,mode) {
            var mode = mode ? mode : "over";
            if (mode == "over") {
                d3.selectAll(".neighborhood" + d.id)
                    .style("fill", "yellow");
                d3.selectAll(".neighborhood" + d.id)
                    .style("opacity", ".3");
            }
            else {
                d3.selectAll(".neighborhood" + d.id)
                    .style("fill", colorScale(d.change));
                d3.selectAll(".neighborhood" + d.id)
                    .style("opacity", "1");
            }
        }

        function addActiveClass(d){
            d3.selectAll(".neighborhood" + d.id).classed("active", true);
            activeList.push(d.id);
        }

        function removeActiveClass(d){
            d3.selectAll(".neighborhood" + d.id).classed("active", false);
            // Find and remove item from an array
            var i = activeList.indexOf(d.id);
            if(i != -1) { activeList.splice(i, 1); }
        }

        g.selectAll( "path" )
            .data( neighborhoods )
          .enter()
            .append( "path" )
            .attr("class", function(d) {
                return isInArray(d.id, activeList) ?
                    "neighborhood" + d.id + " active":
                    "neighborhood" + d.id; })
            .attr("d", path)
            .style("fill", function(d) { return colorScale(d.change); })
            .on("mouseover", function(d) {
                // if not active, activate hover logic
                !d3.selectAll(".neighborhood" + d.id).classed("active") ?
                    inactiveHoverStyle(d,"over"):null;
                // show labels on mouseover
                d3.select(".neighborhood-label-backer" + d.id)
                    .style("display","block");
                d3.select(".neighborhood-label" + d.id)
                    .style("display","block");
            })
            .on("mouseout", function(d) {
                // if not active, activate hover logic
                !d3.selectAll(".neighborhood" + d.id).classed("active") ?
                    inactiveHoverStyle(d,"out"):null;
                // show labels on mouseout
                d3.select(".neighborhood-label-backer" + d.id)
                    .style("display","none");
                d3.select(".neighborhood-label" + d.id)
                    .style("display", "none");
            })
            .on("click", function(d) {
                // Add | Remove active class on click
                d3.selectAll(".neighborhood" + d.id).classed("active") ?
                    removeActiveClass(d):
                    addActiveClass(d);
                redraw();
            });

        // Neighborhood Boundaries ONLY between Neighborhoods
        g.append("path")
            .datum(topojson.mesh(json,json.objects.neighborhoods,
                function(a, b) { return a.id !== b.id; }))
            .attr("d", path)
            .attr("class", "neighborhood-boundary");

        // neighborhood-labels: hidden by default
        g.selectAll(".neighborhood-label-backer")
            .data( neighborhoods )
          .enter().append("text")
            .attr("class", function(d) { return "neighborhood-label-backer" + d.id; })
            .attr("transform", function(d) {
                return "translate(" + path.centroid(d) + ")"; })
            .text(function(d) { return d.id.replace(/_/g, " "); })
            .style("display", "none")
            .style("stroke-width", "3px")
            .style("stroke", "white");

        g.selectAll(".neighborhood-label")
            .data( neighborhoods )
          .enter().append("text")
            .attr("class", function(d) { return "neighborhood-label" + d.id; })
            .attr("transform", function(d) {
                return "translate(" + path.centroid(d) + ")"; })
            .text(function(d) { return d.id.replace(/_/g, " "); })
            .style("display", "none");
    };

};

redraw();

</script>
